<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gas Law Particle Simulator</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">


<style>
:root {
  --bg: #f6f7fb;
  --card: #ffffff;
  --border: #e6e8f0;
  --text: #0f172a;
  --muted: #64748b;
  --accent: #2f6fed;
  --shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
  --radius: 16px;
  --focus: 0 0 0 3px rgba(47, 111, 237, 0.28);
}

* { box-sizing: border-box; }

body {
  margin:0;
  background: var(--bg);
  color: var(--text);
  font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}
.wrap { max-width:1180px; margin:auto; padding:24px; }
.layout { display:grid; grid-template-columns: 1fr; gap:18px; }
.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding:18px;
  box-shadow: var(--shadow);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.card:hover { transform: translateY(-1px); box-shadow: 0 14px 34px rgba(15, 23, 42, 0.12); }

.controls {
  display:grid;
  gap:18px;
}
.controls-grid {
  display:grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap:18px;
}
.control-group {
  display:grid;
  gap:10px;
  padding:12px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: #fbfcff;
}
.control-group label {
  font-size:13px;
  font-weight:600;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.06em;
}
.control-row {
  display:grid;
  grid-template-columns: 1fr auto;
  gap:12px;
  align-items:center;
}

.value-pill {
  min-width:64px;
  text-align:right;
  font-weight:600;
  color: var(--text);
  background: #eef3ff;
  border-radius: 10px;
  padding:6px 10px;
  font-variant-numeric: tabular-nums;
}

input[type=range] {
  width:100%;
  appearance: none;
  height:6px;
  border-radius:999px;
  background: linear-gradient(90deg, var(--accent), #9bbcff);
  outline: none;
}
input[type=range]::-webkit-slider-thumb {
  appearance: none;
  width:18px;
  height:18px;
  border-radius:50%;
  background: var(--card);
  border: 2px solid var(--accent);
  box-shadow: 0 2px 8px rgba(47, 111, 237, 0.25);
}
input[type=range]::-moz-range-thumb {
  width:18px;
  height:18px;
  border-radius:50%;
  background: var(--card);
  border: 2px solid var(--accent);
  box-shadow: 0 2px 8px rgba(47, 111, 237, 0.25);
}
input[type=range]:focus-visible { box-shadow: var(--focus); }

.controls-meta {
  display:grid;
  grid-template-columns: 1fr minmax(220px, 280px);
  gap:16px;
  align-items:center;
}
.lock-row {
  display:grid;
  gap:6px;
}
.lock-line {
  display:flex;
  gap:12px;
  align-items:center;
  flex-wrap:wrap;
}
.lock-toggle {
  display:flex;
  align-items:center;
  gap:8px;
  font-weight:600;
}
.hint {
  font-size:13px;
  color: var(--muted);
}

.toggle {
  position: relative;
  width:42px;
  height:24px;
  border-radius:999px;
  background: #d8deeb;
  transition: background 0.2s ease;
  cursor: pointer;
}
.toggle::after {
  content:"";
  position:absolute;
  top:3px;
  left:3px;
  width:18px;
  height:18px;
  border-radius:50%;
  background:#ffffff;
  transition: transform 0.2s ease;
  box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
}
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
  position: absolute;
}
.switch input:checked + .toggle {
  background: var(--accent);
}
.switch input:checked + .toggle::after {
  transform: translateX(18px);
}
.switch input:focus-visible + .toggle {
  box-shadow: var(--focus);
}

select {
  width:100%;
  background: #ffffff;
  color: var(--text);
  border-radius: 12px;
  border:1px solid var(--border);
  padding:10px 12px;
  font-weight:500;
}
select:disabled {
  background: #f1f4fb;
  color: #94a3b8;
}
select:focus-visible { box-shadow: var(--focus); outline: none; }

.stats {
  display:grid;
  gap:20px;
  align-content: start;
}
.stats h3 {
  margin:0;
  font-size:14px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}
.stats .stat-list {
  display:grid;
  gap:8px;
  font-weight:600;
  font-variant-numeric: tabular-nums;
  line-height: 1.4;
}
.stats .stat-list span {
  color: var(--muted);
  font-weight:500;
}
.stats .stat-list div {
  display:flex;
  justify-content: space-between;
  gap:12px;
}

.stats .stat-graph {
  display:grid;
  gap:6px;
}
.stats .stat-graph-label {
  font-size:12px;
  font-weight:600;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}
.stats .stat-graph canvas {
  width:100%;
  height:48px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: linear-gradient(180deg, #ffffff 0%, #f4f7ff 100%);
}

.simulation {
  display:grid;
  gap:14px;
}
.simulation-header {
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
.simulation-header h2 {
  margin:0;
  font-size:20px;
  font-weight:700;
}
.badge-row {
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}
.badge {
  font-size:12px;
  font-weight:600;
  color: var(--accent);
  background: #eef3ff;
  padding:4px 8px;
  border-radius: 999px;
}

.canvas-wrap {
  padding:16px;
  border: 1px solid var(--border);
  border-radius: 14px;
  background: linear-gradient(180deg, #ffffff 0%, #f7f9ff 100%);
}
canvas {
  width:100%;
  border-radius:12px;
  border:1px solid #e3e7f4;
  background-image: radial-gradient(circle at 1px 1px, rgba(15, 23, 42, 0.08) 1px, transparent 0);
  background-size: 18px 18px;
}

@media (min-width: 960px) {
  .layout { grid-template-columns: 280px 1fr; }
  .controls { grid-column: 1 / -1; }
}

@media (max-width: 959px) {
  .controls-grid { grid-template-columns: 1fr 1fr; }
  .layout { grid-template-columns: 1fr; }
  .stats { grid-template-columns: repeat(3, minmax(0, 1fr)); }
}

@media (max-width: 720px) {
  .controls-grid { grid-template-columns: 1fr; }
  .controls-meta { grid-template-columns: 1fr; }
  .stats { grid-template-columns: 1fr; }
  .value-pill { text-align:left; }
}
</style>
</head>

<body>
<div class="wrap">
  <div class="layout">
    <div class="card controls" aria-label="Simulation controls">
      <div class="controls-grid">
        <div class="control-group">
          <label for="vol">Volume</label>
          <div class="control-row">
            <input id="vol" type="range" min="20" max="100" value="70" aria-label="Volume slider">
            <div id="volVal" class="value-pill" aria-live="polite"></div>
          </div>
        </div>
        <div class="control-group">
          <label for="temp">Temperature</label>
          <div class="control-row">
            <input id="temp" type="range" min="1" max="100" value="50" aria-label="Temperature slider">
            <div id="tempVal" class="value-pill" aria-live="polite"></div>
          </div>
        </div>
        <div class="control-group">
          <label for="press">Pressure</label>
          <div class="control-row">
            <input id="press" type="range" min="1" max="100" value="35" aria-label="Pressure slider">
            <div id="pressVal" class="value-pill" aria-live="polite"></div>
          </div>
        </div>
      </div>

      <div class="controls-meta">
        <div class="lock-row">
          <div class="lock-line">
            <label class="lock-toggle switch">
              <input id="lockToggle" type="checkbox" role="switch" aria-label="Toggle lock">
              <span class="toggle" aria-hidden="true"></span>
              Lock
            </label>
            <span class="hint">Keeps <b>P × V / T</b> constant</span>
          </div>
        </div>
        <div>
          <select id="lock" aria-label="Lock target">
            <option value="none">None</option>
            <option value="volume">Volume</option>
            <option value="temp">Temperature</option>
            <option value="pressure">Pressure</option>
          </select>
        </div>
      </div>
    </div>

    <div class="card stats">
      <h3>Stats</h3>
      <div id="stats" class="stat-list"></div>
          <div class="stat-graph" aria-label="Collisions per second graph">
        <div class="stat-graph-label">Collisions / sec</div>
        <canvas id="collisionGraph" width="240" height="60"></canvas>
      </div>
    </div>

    <div class="card simulation">
      <div class="simulation-header">
        <h2>Simulation</h2>
        <div class="badge-row" aria-label="Live values">
          <span class="badge" id="badgeP">P: 0</span>
          <span class="badge" id="badgeV">V: 0</span>
          <span class="badge" id="badgeT">T: 0</span>
        </div>
      </div>
      <div class="canvas-wrap">
        <canvas id="c" width="900" height="560"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const volEl = document.getElementById("vol");
const tempEl = document.getElementById("temp");
const pressEl = document.getElementById("press");
const lockEl = document.getElementById("lock");
const lockToggle = document.getElementById("lockToggle");

const volVal = document.getElementById("volVal");
const tempVal = document.getElementById("tempVal");
const pressVal = document.getElementById("pressVal");
const stats = document.getElementById("stats");
const badgeP = document.getElementById("badgeP");
const badgeV = document.getElementById("badgeV");
const badgeT = document.getElementById("badgeT");
const collisionGraph = document.getElementById("collisionGraph");
const collisionGraphCtx = collisionGraph.getContext("2d");

const R = 4;
const drag = 0.999;
const restitution = 0.98;
const maxParticles = 260;

let particles = [];
let gasConstant = (Number(pressEl.value)*Number(volEl.value))/Math.max(1,Number(tempEl.value));
let lockedValue = null;
let collisionsPerSecond = 0;
let collisionAccumulator = 0;
let timeAccumulator = 0;
let lastFrameTime = null;
const collisionHistory = Array.from({ length: 90 }, () => 0);

// ---------------- utilities ----------------
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const rand = (a,b)=>a+Math.random()*(b-a);
const updateGasConstant = () => {
  gasConstant = (P() * V()) / T();
};

// ---------------- gas law ----------------
const P = ()=>Number(pressEl.value);
const V = ()=>Number(volEl.value);
const T = ()=>Math.max(1,Number(tempEl.value));

// ---------------- container ----------------
function getBox(){
  const t = (V()-20)/80;
  const m = lerp(220,40,t);
  return { l:m, r:canvas.width-m, t:m*0.75, b:canvas.height-m*0.75 };
}

// ---------------- particles ----------------
function makeParticle(box){
  const a = Math.random()*Math.PI*2;
  const s = rand(0.4,1);
  return { x:rand(box.l+R,box.r-R), y:rand(box.t+R,box.b-R), vx:Math.cos(a)*s, vy:Math.sin(a)*s };
}

function ensureParticles(){
  const box = getBox();
  const area = (box.r-box.l)*(box.b-box.t);
  const maxByArea = Math.floor((area*0.45)/(Math.PI*R*R));
  const target = Math.min(Math.round(lerp(20,maxParticles,P()/100)), maxByArea);
  while(particles.length<target) particles.push(makeParticle(box));
  while(particles.length>target) particles.pop();
}

function resolveCollisions(){
   let collisions = 0;
  for(let i=0;i<particles.length;i++){
    for(let j=i+1;j<particles.length;j++){
      const a=particles[i],b=particles[j];
      const dx=b.x-a.x,dy=b.y-a.y,d2=dx*dx+dy*dy,md=R*2;
      if(d2>0 && d2<md*md){
        const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,o=(md-d)*0.5;
        a.x-=nx*o; a.y-=ny*o; b.x+=nx*o; b.y+=ny*o;
        const rvx=b.vx-a.vx,rvy=b.vy-a.vy,vn=rvx*nx+rvy*ny;
        if(vn<0){
          const imp=-vn;
          a.vx-=imp*nx; a.vy-=imp*ny; b.vx+=imp*nx; b.vy+=imp*ny;
          collisions += 1;
        }
      }
    }
  }
  return collisions;
}

// ---------------- apply lock ----------------
function applyGasLaw(changed){
  const lock = lockEl.value;
  if(lock === "none") return;

  if(lock === "volume"){
    volEl.value = lockedValue; // freeze volume
    if(changed === "pressure"){
      const targetTemp = (P()*lockedValue)/gasConstant;
      const clampedTemp = clamp(targetTemp,1,100);
      tempEl.value = clampedTemp;
      if(clampedTemp !== targetTemp){
        pressEl.value = clamp((gasConstant*clampedTemp)/lockedValue,1,100);
      }
    }
    if(changed === "temp"){
      const targetPress = (gasConstant*T())/lockedValue;
      const clampedPress = clamp(targetPress,1,100);
      pressEl.value = clampedPress;
      if(clampedPress !== targetPress){
        tempEl.value = clamp((clampedPress*lockedValue)/gasConstant,1,100);
      }
    }
  }

  if(lock === "temp"){
    tempEl.value = lockedValue; // freeze temp
     if(changed === "pressure"){
      const targetVol = (gasConstant*lockedValue)/P();
      const clampedVol = clamp(targetVol,20,100);
      volEl.value = clampedVol;
      if(clampedVol !== targetVol){
        pressEl.value = clamp((gasConstant*lockedValue)/clampedVol,1,100);
      }
    }
    if(changed === "volume"){
      const targetPress = (gasConstant*lockedValue)/V();
      const clampedPress = clamp(targetPress,1,100);
      pressEl.value = clampedPress;
      if(clampedPress !== targetPress){
        volEl.value = clamp((gasConstant*lockedValue)/clampedPress,20,100);
      }
    }
  }

  if(lock === "pressure"){
    pressEl.value = lockedValue; // freeze pressure
    if(changed === "volume"){
      const targetTemp = (lockedValue*V())/gasConstant;
      const clampedTemp = clamp(targetTemp, 1, 100);
      tempEl.value = clampedTemp;
      if(clampedTemp !== targetTemp){
        volEl.value = clamp((gasConstant*clampedTemp)/lockedValue, 20, 100);
      }
    }
    if(changed === "temp"){
      const targetVol = (gasConstant*T())/lockedValue;
      const clampedVol = clamp(targetVol, 20, 100);
      volEl.value = clampedVol;
      if(clampedVol !== targetVol){
        tempEl.value = clamp((lockedValue*clampedVol)/gasConstant, 1, 100);
      }
    }
  }
}

// ---------------- input handlers ----------------
// Only apply changes if the slider is NOT locked
volEl.addEventListener("input", ()=>{
  if(lockEl.value === "none") updateGasConstant();
  if(lockEl.value !== "volume") applyGasLaw("volume");
});
tempEl.addEventListener("input", ()=>{
  if(lockEl.value === "none") updateGasConstant();
  if(lockEl.value !== "temp") applyGasLaw("temp");
});
pressEl.addEventListener("input", ()=>{
  if(lockEl.value === "none") updateGasConstant();
  if(lockEl.value !== "pressure") applyGasLaw("pressure");
});

lockEl.addEventListener("change", ()=>{
  const lock = lockEl.value;
  lockToggle.checked = lock !== "none";
  lockEl.disabled = lock === "none";
  if(lock === "none"){
    lockedValue = null;
    updateGasConstant();
  } else if(lock === "volume") lockedValue = V();
  else if(lock === "temp") lockedValue = T();
  else if(lock === "pressure") lockedValue = P();

    updateGasConstant();
});

lockToggle.addEventListener("change", ()=>{
  if(lockToggle.checked){
    if(lockEl.value === "none") lockEl.value = "temp";
    lockEl.disabled = false;
  } else {
    lockEl.value = "none";
    lockEl.disabled = true;
  }
  lockEl.dispatchEvent(new Event("change"));
});

// ---------------- loop ----------------
function step(){
  ensureParticles();

  const box=getBox();
  const speed=lerp(0.4,3.2,T()/100);
  const maxSpeed=8*speed;
  let collisionsThisFrame = 0;

  for(let s=0;s<3;s++){
    for(const p of particles){
      const m=Math.hypot(p.vx,p.vy)||0.0001;
      p.vx=(p.vx/m)*lerp(m,speed,0.02);
      p.vy=(p.vy/m)*lerp(m,speed,0.02);

      const sp=Math.hypot(p.vx,p.vy);
      if(sp>maxSpeed){ p.vx=p.vx/sp*maxSpeed; p.vy=p.vy/sp*maxSpeed; }

      p.x+=p.vx/3; p.y+=p.vy/3;

      if(p.x<box.l+R){p.x=box.l+R;p.vx=Math.abs(p.vx)*restitution;}
      if(p.x>box.r-R){p.x=box.r-R;p.vx=-Math.abs(p.vx)*restitution;}
      if(p.y<box.t+R){p.y=box.t+R;p.vy=Math.abs(p.vy)*restitution;}
      if(p.y>box.b-R){p.y=box.b-R;p.vy=-Math.abs(p.vy)*restitution;}

      p.vx*=drag; p.vy*=drag;
    }
    collisionsThisFrame += resolveCollisions();
  }

  const now = performance.now();
  if(lastFrameTime === null){
    lastFrameTime = now;
  }
  const delta = now - lastFrameTime;
  lastFrameTime = now;
  timeAccumulator += delta;
  collisionAccumulator += collisionsThisFrame;
  if(timeAccumulator >= 1000){
    collisionsPerSecond = collisionAccumulator / (timeAccumulator / 1000);
    collisionAccumulator = 0;
    timeAccumulator = 0;
      collisionHistory.push(collisionsPerSecond);
    if(collisionHistory.length > 90){
      collisionHistory.shift();
    }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="rgba(186, 209, 255, 0.85)";
  ctx.strokeRect(box.l,box.t,box.r-box.l,box.b-box.t);

  let avg=0;
  for(const p of particles){
    avg+=Math.hypot(p.vx,p.vy);
    ctx.beginPath();
    ctx.arc(p.x,p.y,R,0,Math.PI*2);
    const speedRatio = clamp(Math.hypot(p.vx,p.vy) / maxSpeed, 0, 1);
    const lightness = lerp(70, 52, speedRatio);
    ctx.fillStyle = `hsl(210, 85%, ${lightness}%)`;
    ctx.fill();
  }
  const displayConstant = lockEl.value === "none" ? (P() * V()) / T() : gasConstant;
  stats.innerHTML=
    `<div><span>Particles</span>${particles.length}</div>
     <div><span>Avg speed</span>${(avg/particles.length).toFixed(2)}</div>
     <div><span>Avg collisions/sec</span>${collisionsPerSecond.toFixed(1)}</div>
     <div><span>P×V/T</span>${displayConstant.toFixed(2)}</div>`;

  const graphWidth = collisionGraph.clientWidth;
  const graphHeight = collisionGraph.clientHeight;
  const graphRatio = window.devicePixelRatio || 1;
  if(collisionGraph.width !== Math.floor(graphWidth * graphRatio) || collisionGraph.height !== Math.floor(graphHeight * graphRatio)){
    collisionGraph.width = Math.floor(graphWidth * graphRatio);
    collisionGraph.height = Math.floor(graphHeight * graphRatio);
  }
  collisionGraphCtx.clearRect(0, 0, collisionGraph.width, collisionGraph.height);
  const maxCollision = Math.max(10, ...collisionHistory);
  const padding = 8 * graphRatio;
  const innerWidth = collisionGraph.width - padding * 2;
  const innerHeight = collisionGraph.height - padding * 2;
  collisionGraphCtx.strokeStyle = "rgba(47, 111, 237, 0.9)";
  collisionGraphCtx.lineWidth = 2 * graphRatio;
  collisionGraphCtx.beginPath();
  collisionHistory.forEach((value, index) => {
    const x = padding + (innerWidth * index) / Math.max(1, collisionHistory.length - 1);
    const y = padding + innerHeight - (value / maxCollision) * innerHeight;
    if(index === 0){
      collisionGraphCtx.moveTo(x, y);
    } else {
      collisionGraphCtx.lineTo(x, y);
    }
  });
  collisionGraphCtx.stroke();

  volVal.textContent=V().toFixed(1);
  tempVal.textContent=T().toFixed(1);
  pressVal.textContent=P().toFixed(1);
  badgeP.textContent = `P: ${P().toFixed(1)}`;
  badgeV.textContent = `V: ${V().toFixed(1)}`;
  badgeT.textContent = `T: ${T().toFixed(1)}`;

  requestAnimationFrame(step);
}

lockEl.dispatchEvent(new Event("change"));
step();
</script>
</body>
</html>
