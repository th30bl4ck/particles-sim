<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Particle Gas Simulator</title>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b0c10; color:#e8e8e8; }
    .wrap { max-width: 1000px; margin: 0 auto; padding: 16px; }
    .top { display:flex; gap:12px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
    .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); border-radius: 16px; padding: 12px; }
    canvas { width:100%; height:auto; border-radius: 16px; border: 1px solid rgba(255,255,255,0.12); background: radial-gradient(800px 400px at 40% 30%, rgba(90,160,255,0.12), rgba(0,0,0,0)); }
    .controls { display:grid; gap:10px; min-width: 310px; }
    .row { display:grid; grid-template-columns: 92px 1fr 70px; gap:10px; align-items:center; }
    input[type="range"] { width:100%; }
    .small { opacity:0.8; font-size: 13px; line-height:1.35; }
    .stats { display:grid; gap:6px; min-width: 260px; }
    .badge { display:inline-block; padding:4px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.10); font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="card controls">
        <div class="row">
          <div>Volume</div>
          <input id="vol" type="range" min="20" max="100" value="70" />
          <div id="volVal">70</div>
        </div>

        <div class="row">
          <div>Temp</div>
          <input id="temp" type="range" min="0" max="100" value="50" />
          <div id="tempVal">50</div>
        </div>

        <div class="row">
          <div>Pressure</div>
          <input id="press" type="range" min="0" max="100" value="35" />
          <div id="pressVal">35</div>
        </div>

        <div class="small">
          <span class="badge">Volume</span> changes container size<br/>
          <span class="badge">Temp</span> scales speeds<br/>
          <span class="badge">Pressure</span> changes particle count
        </div>
      </div>

      <div class="card stats" id="stats">
        <div><b>Stats</b></div>
        <div id="particleCount">Particles: —</div>
        <div id="avgSpeed">Avg speed: —</div>
        <div class="small" id="hint"></div>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <canvas id="c" width="900" height="560"></canvas>
    </div>
  </div>

  <script>
    // -----------------------------
    // Canvas + UI
    // -----------------------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const volEl = document.getElementById("vol");
    const tempEl = document.getElementById("temp");
    const pressEl = document.getElementById("press");

    const volVal = document.getElementById("volVal");
    const tempVal = document.getElementById("tempVal");
    const pressVal = document.getElementById("pressVal");

    const particleCountEl = document.getElementById("particleCount");
    const avgSpeedEl = document.getElementById("avgSpeed");
    const hintEl = document.getElementById("hint");

    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function rand(a,b){ return a + Math.random()*(b-a); }

    // -----------------------------
    // Physics parameters
    // -----------------------------
    const maxParticles = 260;

    const R = 4;                    // particle radius
    const wallRestitution = 0.98;   // bounce bounciness
    const drag = 0.999;             // tiny drag to keep stable

    let particles = [];

    function makeParticle(x, y, speedScale){
      const a = rand(0, Math.PI*2);
      const s = rand(0.6, 1.2) * speedScale;
      return { x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s };
    }

    // container (volume) box inside canvas
    function getBox(){
      const v = Number(volEl.value); // 20..100
      const t = (v - 20) / (100 - 20); // 0..1
      const margin = lerp(220, 40, t);
      const left = margin;
      const top  = margin * 0.75;
      const right = canvas.width - margin;
      const bottom = canvas.height - margin * 0.75;
      return { left, top, right, bottom, w: right-left, h: bottom-top };
    }

    function tempSpeedScale(){
      const T = Number(tempEl.value); // 0..100
      return lerp(0.35, 3.2, T/100);
    }

    // Pressure -> desired particle count, capped by available area so it doesn't "pack into walls"
    function desiredParticleCount(){
      const P = Number(pressEl.value); // 0..100
      const box = getBox();

      const area = box.w * box.h;
      const particleArea = Math.PI * R * R;

      // Rough safe packing limit for this simple solver
      const maxByArea = Math.floor((area * 0.45) / particleArea);

      const want = Math.round(lerp(25, maxParticles, P/100));
      return Math.max(10, Math.min(want, maxByArea));
    }

    function syncUI(){
      volVal.textContent = volEl.value;
      tempVal.textContent = tempEl.value;
      pressVal.textContent = pressEl.value;
    }

    // -----------------------------
    // Helpers
    // -----------------------------
    function nudgeInsideBox(p, box){
      p.x = clamp(p.x, box.left + R, box.right - R);
      p.y = clamp(p.y, box.top + R, box.bottom - R);
    }

    function clampSpeed(p, maxS){
      const s = Math.hypot(p.vx, p.vy);
      if (s > maxS) {
        p.vx = (p.vx / s) * maxS;
        p.vy = (p.vy / s) * maxS;
      }
    }

    // -----------------------------
    // Particle management
    // -----------------------------
    function ensureParticleCount(){
      const target = desiredParticleCount();
      const box = getBox();
      const speedScale = tempSpeedScale();

      while (particles.length < target) {
        const x = rand(box.left + R, box.right - R);
        const y = rand(box.top + R, box.bottom - R);
        particles.push(makeParticle(x, y, speedScale));
      }
      while (particles.length > target) particles.pop();
    }

    // simple pairwise collision
    function resolveCollisions(){
      for (let i=0; i<particles.length; i++){
        for (let j=i+1; j<particles.length; j++){
          const a = particles[i], b = particles[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist2 = dx*dx + dy*dy;
          const minDist = R*2;

          if (dist2 > 0 && dist2 < minDist*minDist){
            const dist = Math.sqrt(dist2);
            const nx = dx / dist;
            const ny = dy / dist;

            // separate overlap
            const overlap = (minDist - dist) * 0.5;
            a.x -= nx * overlap; a.y -= ny * overlap;
            b.x += nx * overlap; b.y += ny * overlap;

            // relative velocity along normal
            const rvx = b.vx - a.vx;
            const rvy = b.vy - a.vy;
            const vn = rvx*nx + rvy*ny;

            // only if moving towards each other
            if (vn < 0){
              // equal mass elastic-ish impulse
              const impulse = (-2 * vn) * 0.5;
              a.vx -= impulse * nx;
              a.vy -= impulse * ny;
              b.vx += impulse * nx;
              b.vy += impulse * ny;
            }
          }
        }
      }
    }

    // -----------------------------
    // Main loop
    // -----------------------------
    function step(){
      syncUI();
      ensureParticleCount();

      const box = getBox();
      const speedScale = tempSpeedScale();

      // Stability knobs (these fix the "sticking to the side")
      const maxSpeed = 8 * speedScale; // prevents velocity explosions
      const substeps = 3;              // more stable at high density
      const iters = 2;                 // collision solver iterations each substep

      // physics
      for (let s = 0; s < substeps; s++) {

        // move
        for (const p of particles){
          // gently match temperature so changing temp isn't instant
          const mag = Math.hypot(p.vx, p.vy) || 0.0001;
          const desired = speedScale;
          const blend = 0.02;
          const newMag = mag + (desired - mag) * blend;
          p.vx = (p.vx / mag) * newMag;
          p.vy = (p.vy / mag) * newMag;

          clampSpeed(p, maxSpeed);

          // integrate (split into substeps)
          p.x += p.vx / substeps;
          p.y += p.vy / substeps;

          // walls
          if (p.x < box.left + R){ p.x = box.left + R; p.vx = Math.abs(p.vx) * wallRestitution; }
          if (p.x > box.right - R){ p.x = box.right - R; p.vx = -Math.abs(p.vx) * wallRestitution; }
          if (p.y < box.top + R){ p.y = box.top + R; p.vy = Math.abs(p.vy) * wallRestitution; }
          if (p.y > box.bottom - R){ p.y = box.bottom - R; p.vy = -Math.abs(p.vy) * wallRestitution; }

          p.vx *= drag;
          p.vy *= drag;
        }

        // collisions (iterate a couple times)
        for (let k = 0; k < iters; k++){
          resolveCollisions();
          // after collision separation, ensure nobody is shoved into the walls
          for (const p of particles) nudgeInsideBox(p, box);
        }
      }

      // stats
      let speedSum = 0;
      for (const p of particles) speedSum += Math.hypot(p.vx, p.vy);
      const avg = speedSum / Math.max(1, particles.length);

      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // container
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.fillStyle = "rgba(255,255,255,0.03)";
      ctx.beginPath();
      ctx.roundRect(box.left, box.top, box.w, box.h, 14);
      ctx.fill();
      ctx.stroke();

      // particles
      for (const p of particles){
        ctx.beginPath();
        ctx.arc(p.x, p.y, R, 0, Math.PI*2);
        ctx.fillStyle = "rgba(120,200,255,0.9)";
        ctx.fill();
      }

      particleCountEl.textContent = `Particles: ${particles.length}`;
      avgSpeedEl.textContent = `Avg speed: ${avg.toFixed(2)}`;

      const v = Number(volEl.value), t = Number(tempEl.value), pr = Number(pressEl.value);
      hintEl.textContent =
        (v < 35 ? "Tiny volume → more wall hits + collisions." :
         v > 80 ? "Big volume → particles spread out more." : "Balanced volume.") +
        (t < 20 ? " Low temp → slow drift." :
         t > 80 ? " High temp → " : "") +
        (pr > 70 ? " High pressure → crowded gas." : "");

      requestAnimationFrame(step);
    }

    // roundRect polyfill
    if (!ctx.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
        r = Math.min(r, w/2, h/2);
        this.moveTo(x+r, y);
        this.arcTo(x+w, y, x+w, y+h, r);
        this.arcTo(x+w, y+h, x, y+h, r);
        this.arcTo(x, y+h, x, y, r);
        this.arcTo(x, y, x+w, y, r);
        this.closePath();
      };
    }

    // listen for slider changes
    [volEl, tempEl, pressEl].forEach(el => el.addEventListener("input", () => {
      const box = getBox();
      for (const p of particles) nudgeInsideBox(p, box);
    }));

    // start
    syncUI();
    step();
  </script>
</body>
</html>